variable "id" {
  description = "The ID of the OpenID client."
  type        = string
}

variable "name" {
  description = "The name of the OpenID client. Defaults to Title Case version of `id`."
  type        = string
  default     = null
  nullable    = true
}

variable "realm" {
  description = "The realm in which to create the client."
  type        = string
}

variable "enabled" {
  description = "Whether the OpenID client is enabled."
  type        = bool
  default     = true
}

variable "description" {
  description = "The description of this client in the GUI."
  type        = string
  default     = null
  nullable    = true
}

variable "always_display_in_console" {
  description = "Always list this client in the Account UI, even if the user does not have an active session."
  type        = bool
  default     = false
}

variable "access_type" {
  description = <<EOT
Specifies the type of client, which can be one of the following:

CONFIDENTIAL - Used for server-side clients that require both client ID and secret when authenticating. This client should be used for applications using the Authorization Code or Client Credentials grant flows.
PUBLIC - Used for browser-only applications that do not require a client secret, and instead rely only on authorized redirect URIs for security. This client should be used for applications using the Implicit grant flow.
BEARER-ONLY - Used for services that never initiate a login. This client will only allow bearer token requests.
EOT
  type        = string
  validation {
    condition     = contains(["CONFIDENTIAL", "PUBLIC", "BEARER-ONLY"], var.access_type)
    error_message = "access_type must be one of: CONFIDENTIAL, PUBLIC, BEARER-ONLY."
  }
}

# I just want to generate the secret for now, maybe later I'll add this back
# variable "client_secret" {
#   description = "The secret for clients with an access_type of CONFIDENTIAL or BEARER-ONLY. If omitted, this will be generated by Keycloak."
#   type        = string
#   default     = null
#   nullable    = true
#   sensitive   = true
# }

variable "access_settings" {
  description = "A map of access settings for the OpenID client."
  type = object({
    rootUrl      = optional(string)
    adminUrl     = optional(string)
    baseUrl      = optional(string)
    redirectUris = optional(list(string))
    webOrigins   = optional(list(string))
  })
  default = {}
}

variable "capabilities" {
  description = "A map of capabilities for the OpenID client."
  type = object({
    standardFlowEnabled                   = optional(bool)
    implicitFlowEnabled                   = optional(bool)
    directAccessGrantsEnabled             = optional(bool)
    serviceAccountsEnabled                = optional(bool)
    standardTokenExchangeEnabled          = optional(bool)
    oauth2DeviceAuthorizationGrantEnabled = optional(bool)
    pkceCodeChallengeMethod               = optional(string)
  })
  default = {}
  validation {
    condition = (
      !contains(keys(var.capabilities), "pkceCodeChallengeMethod") ||
      var.capabilities.pkceCodeChallengeMethod == null ||
      contains(["plain", "S256"], var.capabilities.pkceCodeChallengeMethod)
    )
    error_message = "pkceCodeChallengeMethod must be either 'plain', 'S256', or null."
  }
}

variable "login" {
  description = "This section is used to configure login settings for the OpenID client."
  type = object({
    theme                  = optional(string)
    consentRequired        = optional(bool)
    displayOnConsentScreen = optional(bool)
    consentScreentText     = optional(string)
  })
  default = {}
}

variable "logout" {
  description = "This section is used to configure logout settings for the OpenID client."
  type = object({
    frontChannelLogoutEnabled              = optional(bool)
    backchannelLogoutUrl                   = optional(string)
    frontchannelLogoutUrl                  = optional(string)
    backchannelLogoutSessionRequired       = optional(bool)
    backchannelLogoutRevokeOfflineSessions = optional(bool)
  })
  default = {}
}

variable "authorization" {
  description = <<EOT
(Optional) When this block is present, fine-grained authorization will be enabled for this client.
The client's access_type must be CONFIDENTIAL, and service_accounts_enabled must be true.

This block has the following arguments:
- policyEnforcementMode (Required): ENFORCING, PERMISSIVE, or DISABLED.
- decisionStrategy (Optional): AFFIRMATIVE, CONSENSUS, or UNANIMOUS.
- allowRemoteResourceManagement (Optional): bool, defaults to false.
- keepDefaults (Optional): bool, defaults to false.
EOT
  type = object({
    policyEnforcementMode         = string
    decisionStrategy              = optional(string)
    allowRemoteResourceManagement = optional(bool)
    keepDefaults                  = optional(bool)
  })
  default  = null
  nullable = true
  validation {
    condition = (
      var.authorization == null || contains(["ENFORCING", "PERMISSIVE", "DISABLED"], var.authorization.policyEnforcementMode)
    )
    error_message = "policyEnforcementMode must be one of: ENFORCING, PERMISSIVE, DISABLED."
  }
}

variable "extra_config" {
  description = "This section is used to configure advanced settings of this client related to OpenID Connect protocol."
  type        = map(string)
  default     = null
  nullable    = true
}

variable "scopes" {
  description = <<EOF
A set of all of the client scopes for this client.
EOF
  type = object({
    default = optional(list(string))
    optional = optional(list(string))
  })
  default = {}
}

variable "protocol_mappers" {
  description = <<EOF
A set of all of the protocol mappers for this client. 
EOF
  default = []
  type = set(object({
    name            = string
    type            = string
    audienceResolve = optional(object({}))
    audience = optional(object({
      includedClient   = optional(string)
      includedCustom   = optional(string)
      addToIdToken     = optional(bool)
      addToAccessToken = optional(bool)
    }))
    fullName = optional(object({
      addToIdToken     = optional(bool)
      addToAccessToken = optional(bool)
      addToUserinfo    = optional(bool)
    }))
    groupMembership = optional(object({
      claimName        = string
      fullPath         = optional(bool)
      addToIdToken     = optional(bool)
      addToAccessToken = optional(bool)
      addToUserinfo    = optional(bool)
    }))
    hardcodedClaim = optional(object({
      name             = string # claim_name
      value            = string
      valueType        = optional(string)
      addToIdToken     = optional(bool)
      addToAccessToken = optional(bool)
      addToUserinfo    = optional(bool)
    }))
    hardcodedRole = optional(object({
      name = string
    }))
    sub = optional(object({
      addToAccessToken        = optional(bool)
      addToTokenIntrospection = optional(bool)
    }))
    userAttribute = optional(object({
      name             = string # user_attribute
      claimName        = string
      valueType        = optional(string)
      aggregate        = optional(bool) # aggregate_attributes
      multivalued      = optional(bool)
      addToIdToken     = optional(bool)
      addToAccessToken = optional(bool)
      addToUserinfo    = optional(bool)
    }))
    userClientRole = optional(object({
      claimName               = string
      clientIdForRoleMappings = optional(string)
      prefix                  = optional(string) # client_role_prefix
      valueType               = optional(string)
      multivalued             = optional(bool)
      addToIdToken            = optional(bool)
      addToAccessToken        = optional(bool)
      addToUserinfo           = optional(bool)
    }))
    userProperty = optional(object({
      name             = string # user_property
      claimName        = string
      valueType        = optional(string)
      addToIdToken     = optional(bool)
      addToAccessToken = optional(bool)
      addToUserinfo    = optional(bool)
    }))
    userRealmRole = optional(object({
      claimName               = string
      realmRolePrefix         = optional(string)
      valueType               = optional(string)
      multivalued             = optional(bool)
      addToIdToken            = optional(bool)
      addToAccessToken        = optional(bool)
      addToUserinfo           = optional(bool)
      addToTokenIntrospection = optional(bool)
    }))
    userSessionNote = optional(object({
      name             = string # session_note
      claimName        = string
      valueType        = optional(string)
      addToIdToken     = optional(bool)
      addToAccessToken = optional(bool)
    }))
  }))
}

variable "permissions" {
  description = <<EOT
This is part of a preview keycloak feature. You need to enable this feature to be able to use this resource. More information about enabling the preview feature can be found here: https://www.keycloak.org/securing-apps/token-exchange

When enabling Openid Client Permissions, Keycloak does several things automatically:

Enable Authorization on build-in realm-management client
Create scopes "view", "manage", "configure", "map-roles", "map-roles-client-scope", "map-roles-composite", " token-exchange"
Create a resource representing the openid client
Create all scope based permission for the scopes and openid client resource
If the realm-management Authorization is not enable, you have to create a dependency (depends_on) with the policy and the openid client.
EOT
  type = set(object({
    scope = string
    policies = optional(list(string))
    description = optional(string)
    decisionStrategy = optional(string)
  }))
  default = null 
  nullable = true
  # use terrraform validation to check if scope is one of the allowed values if the variable is not null
  validation {
    condition = (
      var.permissions == null ||
      alltrue([for p in var.permissions : contains(["view", "manage", "configure", "map-roles", "map-roles-client-scope", "map-roles-composite", "token-exchange"], p.scope)])
    )
    error_message = "Each permission's scope must be one of: view, manage, configure, map-roles, map-roles-client-scope, map-roles-composite, token-exchange."
  }
}
